from temporalio import activity
from optimizer_sentinel.diagnostics.agent_tracer import trace_event
from optimizer_sentinel.adapters.github_adapter import GitHubAdapter
from optimizer_sentinel.storage.neo4j_anchor import anchor_event as anchor_in_neo4j

@activity.defn
async def diagnose(task_body: str) -> dict:
    """Activity to diagnose an error from a task description."""
    trace_event("diagnose_activity_started", {"task_body": task_body})
    # In a real scenario, this would involve complex error analysis.
    error_details = {"error": "ImportError", "file": "test_cli.py"}
    trace_event("diagnose_activity_completed", {"error_details": error_details})
    return error_details

@activity.defn
async def generate_patch(error: dict, task: dict) -> dict:
    """Activity to generate a patch based on a diagnosed error."""
    trace_event("generate_patch_activity_started", {"error": error})
    file_path = task.get("file_path", "unknown_file.py")
    patch = {
        "id": task.get("id", "temp-id"),
        "message": f"Fix: {error.get('error', 'Unknown Error')} in {file_path}",
        "body": f"This patch was auto-generated by Jules for task: {task.get('id')}",
        "file_path": file_path,
        "diff": f"# This is a mock patch content for {file_path}\nprint('Hello, Patched World!')\n",
    }
    trace_event("generate_patch_activity_completed", {"patch": patch})
    return patch

@activity.defn
async def commit_and_create_pr(repo_full_name: str, base_branch: str, patch: dict) -> str:
    """Activity to commit a patch to a new branch and create a pull request."""
    trace_event("commit_pr_activity_started", {"repo": repo_full_name})
    github = GitHubAdapter()

    # 1. Commit the patch to a new branch
    new_branch = github.commit_patch(
        repo_full_name=repo_full_name,
        base_branch=base_branch,
        patch=patch
    )
    if not new_branch:
        raise RuntimeError("Failed to commit patch to new branch.")

    # 2. Create the pull request
    pr = github.create_pr(
        repo_full_name=repo_full_name,
        base_branch=base_branch,
        head_branch=new_branch,
        title=patch["message"],
        body=patch["body"]
    )
    if not pr:
        raise RuntimeError("Failed to create pull request.")

    trace_event("commit_pr_activity_completed", {"pr_url": pr.html_url})
    return pr.html_url

@activity.defn
async def anchor_event_activity(task_id: str, patch: dict, pr_url: str):
    """Activity to anchor the event in Neo4j."""
    trace_event("anchor_event_activity_started", {"task_id": task_id})
    # The neo4j_anchor module uses a class internally, but we call the function wrapper
    # We pass a simple dict representation of the PR object
    pr_object_for_anchor = {"html_url": pr_url}
    anchor_in_neo4j(task_id, patch, pr_object_for_anchor)
    trace_event("anchor_event_activity_completed", {"task_id": task_id})