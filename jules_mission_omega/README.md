# Jules Mission Ω: Failure Resilience & Audit Simulation

This module implements "Jules Mission Ω," a self-contained simulation of a mutation-aware, audit-anchored, and failure-resilient AI orchestration kernel. The primary purpose is to demonstrate how an agentic system can survive a total, simultaneous collapse of its primary AI model vendors, failover to a local model, and produce a deterministic, auditable response.

This entire process is designed to be transparent and reproducible, providing the "investor-grade audit evidence" specified in the original design document.

## Core Capabilities Demonstrated

*   **Multi-Vendor Failure Simulation**: The system simulates a scenario where multiple external AI vendors (e.g., Claude, GPT, Gemini) time out simultaneously.
*   **Circuit Breaker Activation**: Upon detecting the failure, a circuit breaker is immediately activated to isolate the external services and prevent further calls.
*   **Graceful Degradation & Local Failover**: The system gracefully degrades by routing the task to a locally hosted model (`Mixtral-8x7B` in this simulation).
*   **Heuristic Validation**: Before generating a final response, a set of heuristic checks (e.g., schema validation, semantic coherence) are run to ensure the local model's output is reliable.
*   **Deterministic Response Generation**: The system produces a deterministic response, meaning the same input will always generate the exact same output. This is critical for regulatory compliance and auditability.
*   **Provenance Anchoring**: Every critical step of the incident—from the initial failure to the final response—is logged as a structured event, ready to be anchored in a provenance graph like Neo4j.
*   **Ruthless Benchmarking**: The performance of the system in its degraded state is benchmarked and logged, providing transparent metrics on latency, semantic drift, and availability.

## Architecture & Components

The simulation is orchestrated by `julesmissionomega.py` and is composed of the following modules:

-   `psi_kernel.py`: Detects the initial vendor failure and activates the system-wide circuit breaker.
-   `reroute_traceback.py`: Logs the initial failure event for traceability.
-   `hf_model_router.py`: Manages loading the local fallback model (a Hugging Face model in this case).
-   `dry_run_harness.py`: Executes the heuristic validation checks to ensure response quality.
-   `mutation_anchor.py`: Formats the incident data into a payload ready for a Neo4j provenance graph.
-   `benchmark_runner.py`: Measures and logs the performance metrics of the system during degraded operation.
-   `julesmissionomega.py`: The main orchestrator class that executes the entire sequence from failure to recovery.

## How to Run the Simulation

The entire simulation can be executed from the root of the repository using the `run_mission.py` script.

```bash
python3 run_mission.py
```

The script will print a detailed, real-time log of each stage of the process:
1.  The initial failure detection and traceback.
2.  The circuit breaker activation.
3.  The local model loading and heuristic checks.
4.  The Neo4j anchor payload.
5.  The final performance benchmarks.
6.  The final, deterministic response generated by the local model.